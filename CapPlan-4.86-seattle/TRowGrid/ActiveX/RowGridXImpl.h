//$$---- activex control header ---- (stActiveXControlHeader)
// copyright by PostWare (S.B.M. Post)
//---------------------------------------------------------------------------
#ifndef RowGridXImplH
#define RowGridXImplH
//---------------------------------------------------------------------------
#include "RowGrid_TLB.h"
#include "..\\RowGrid.h"

class ATL_NO_VTABLE TRowGridXImpl:
  VCLCONTROL_IMPL(TRowGridXImpl, RowGridX, TRowGrid, IRowGridX, DIID_IRowGridXEvents)
{
  unsigned char __fastcall Shift2State(TShiftState Shift);
  IRectXPtr __fastcall Rect2Iface(TRect & Rect);
  IRowCellXPtr __fastcall RowCell2Iface(RowCell & RowCell);
  RowCell __fastcall Iface2RowCell(IRowCellXPtr IRowCellX);
  void __fastcall CanResizeEvent(TObject *Sender, int &NewWidth,
      int &NewHeight, bool &Resize);
  void __fastcall ClickEvent(TObject *Sender);
  void __fastcall ConstrainedResizeEvent(TObject *Sender, int &MinWidth,
      int &MinHeight, int &MaxWidth, int &MaxHeight);
  void __fastcall DblClickEvent(TObject *Sender);
  void __fastcall KeyPressEvent(TObject *Sender, char &Key);
  void __fastcall ResizeEvent(TObject *Sender);
  void __fastcall InsertRowCellEvent(TObject *Sender, RowCell &RowCell,
	  bool &CanInsert);
  void __fastcall RemoveRowCellEvent(TObject *Sender, RowCell &RowCell,
	  bool &CanRemove);
  void __fastcall ClearRowCellEvent(TObject *Sender, RowCell &RowCell,
	  bool &CanClear);
  void __fastcall DragRowCellEvent(TObject *Sender, RowCell &RowCell,
	  TCellState CellState, bool IsCopy, bool &CanDrag);
  void __fastcall DrawFocusRectEvent(TObject *Sender, TRect Rect);
  void __fastcall DrawRowLineEvent(TObject *Sender, int Row, TRect Rect);
  void __fastcall DrawRowCellEvent(TObject *Sender, RowCell RowCell,
	  TRect Rect);
  void __fastcall DblClickRowCellEvent(TObject *Sender, RowCell RowCell);
  void __fastcall MouseDownEvent(TObject *Sender, TMouseButton Button,
	  TShiftState Shift, int X, int Y);
  void __fastcall MouseUpEvent(TObject *Sender, TMouseButton Button,
	  TShiftState Shift, int X, int Y);
  void __fastcall MouseMoveEvent(TObject *Sender, TShiftState Shift, int X,
	  int Y);
  void __fastcall KeyDownEvent(TObject *Sender, unsigned short &Key,
	  TShiftState Shift);
  void __fastcall PaintEvent(TObject *Sender);
public:

  void InitializeControl()
  {
	m_VclCtl->OnCanResize = CanResizeEvent;
	m_VclCtl->OnClick = ClickEvent;
	m_VclCtl->OnConstrainedResize = ConstrainedResizeEvent;
	m_VclCtl->OnDblClick = DblClickEvent;
	m_VclCtl->OnKeyPress = KeyPressEvent;
	m_VclCtl->OnResize = ResizeEvent;
	m_VclCtl->OnInsertRowCell = InsertRowCellEvent;
	m_VclCtl->OnRemoveRowCell = RemoveRowCellEvent;
	m_VclCtl->OnClearRowCell = ClearRowCellEvent;
	m_VclCtl->OnDragRowCell = DragRowCellEvent;
	m_VclCtl->OnDrawFocusRect = DrawFocusRectEvent;
	m_VclCtl->OnDrawRowLine = DrawRowLineEvent;
	m_VclCtl->OnDrawRowCell = DrawRowCellEvent;
	m_VclCtl->OnDblClickRowCell = DblClickRowCellEvent;
	m_VclCtl->OnMouseDown = MouseDownEvent;
	m_VclCtl->OnMouseUp = MouseUpEvent;
	m_VclCtl->OnMouseMove = MouseMoveEvent;
	m_VclCtl->OnKeyDown = KeyDownEvent;
	m_VclCtl->OnPaint = PaintEvent;
  }


// The COM MAP entries declares the interfaces your object exposes (through
// QueryInterface). CComRootObjectEx::InternalQueryInterface only returns
// pointers for interfaces in the COM map. VCL controls exposed as OCXes
// have a minimum set of interfaces defined by the
// VCL_CONTROL_COM_INTERFACE_ENTRIES macro. Add other interfaces supported
// by your object with additional COM_INTERFACE_ENTRY[_xxx] macros.
//
BEGIN_COM_MAP(TRowGridXImpl)
  VCL_CONTROL_COM_INTERFACE_ENTRIES(IRowGridX)
END_COM_MAP()

//$$---- activex control license support (stActiveXControlLicensing)
  // Licensing support
  //
  typedef TLicenseString<TRowGridXImpl> TLicenseClassImpl;
  DECLARE_CLASSFACTORY2(TLicenseClassImpl)

  // Add logic to determine whether this Control is properly licensed on this machine
  // in the following method..
  //
  static const WCHAR* GetLicenseString()
  {
#ifdef DEMO
	return L"";
#else
	return L"{681AAE26-879F-4F1A-B2A3-DECD2A5F5B97}";
#endif
  }

  static const TCHAR* GetLicenseFileName()
  {
	return _T("RowGrid.lic");
  }

  static BOOL IsLicenseValid()
  {
	// By default we validate the license by verifying that the
	// license string GUID is in the .LIC file generated by the Wizard.
	//
	// You may replace the logic of this routine to implement another
	// method to verify that your control is properly licensed.
	//
	return TValidateLicense::IsGUIDInFile(GetLicenseString(), GetLicenseFileName());
  }

// The PROPERTY map stores property descriptions, property DISPIDs,
// property page CLSIDs and IDispatch IIDs. You may use use
// IPerPropertyBrowsingImpl, IPersistPropertyBagImpl, IPersistStreamInitImpl,
// and ISpecifyPropertyPageImpl to utilize the information in you property
// map.
//
// NOTE: The BCB Wizard does *NOT* maintain your PROPERTY_MAP table. You must
//       add or remove entries manually.
//
BEGIN_PROPERTY_MAP(TRowGridXImpl)
  // PROP_PAGE(CLSID_RowGridXPage)
END_PROPERTY_MAP()

/* DECLARE_VCL_CONTROL_PERSISTENCE(CppClass, VclClass) is needed for VCL
 * controls to persist via the VCL streaming mechanism and not the ATL mechanism.
 * The macro adds static IPersistStreamInit_Load and IPersistStreamInit_Save
 * methods to your implementation class, overriding the methods in IPersistStreamImpl.
 * This macro must be manually undefined or removed if you port to C++Builder 4.0. */

DECLARE_VCL_CONTROL_PERSISTENCE(TRowGridXImpl, TRowGrid);

// The DECLARE_ACTIVEXCONTROL_REGISTRY macro declares a static 'UpdateRegistry'
// routine which registers the basic information about your control. The
// parameters expected by the macro are the ProgId & the ToolboxBitmap ID of
// your control.
//
DECLARE_ACTIVEXCONTROL_REGISTRY("RowGrid.RowGridX", 1);

protected:
  STDMETHOD(_set_Font(IFontDisp** Value));
  STDMETHOD(ClearDragState());
  STDMETHOD(DrawTextBiDiModeFlagsReadingOnly(long* Value));
  STDMETHOD(get_AlignDisabled(VARIANT_BOOL* Value));
  STDMETHOD(get_CellBorderWidth(long* Value));
  STDMETHOD(get_CellColor(::OLE_COLOR* Value));
  STDMETHOD(get_CellFrameWidth(long* Value));
  STDMETHOD(get_CheckPosition(VARIANT_BOOL* Value));
  STDMETHOD(get_Color(::OLE_COLOR* Value));
  STDMETHOD(get_Ctl3D(VARIANT_BOOL* Value));
  STDMETHOD(get_DefaultDrawing(VARIANT_BOOL* Value));
  STDMETHOD(get_DoubleBuffered(VARIANT_BOOL* Value));
  STDMETHOD(get_DragCursor(short* Value));
  STDMETHOD(get_DragMode(TxDragMode* Value));
  STDMETHOD(get_DragState(TxDragState* Value));
  STDMETHOD(get_Enabled(VARIANT_BOOL* Value));
  STDMETHOD(get_Font(IFontDisp** Value));
  STDMETHOD(get_FrameWidth(long* Value));
  STDMETHOD(get_MinVisible(long* Value));
  STDMETHOD(get_ParentColor(VARIANT_BOOL* Value));
  STDMETHOD(get_ParentCtl3D(VARIANT_BOOL* Value));
  STDMETHOD(get_RowCount(long* Value));
  STDMETHOD(get_RowHeight(long* Value));
  STDMETHOD(get_RowLineColor(::OLE_COLOR* Value));
  STDMETHOD(get_RowLineWidth(long* Value));
  STDMETHOD(get_TickColor(::OLE_COLOR* Value));
  STDMETHOD(get_Units(long* Value));
  STDMETHOD(get_UnitWidth(long* Value));
  STDMETHOD(get_Visible(VARIANT_BOOL* Value));
  STDMETHOD(get_VisibleDockClientCount(long* Value));
  STDMETHOD(IsRightToLeft(VARIANT_BOOL* Value));
  STDMETHOD(set_CellBorderWidth(long Value));
  STDMETHOD(set_CellColor(::OLE_COLOR Value));
  STDMETHOD(set_CellFrameWidth(long Value));
  STDMETHOD(set_CheckPosition(VARIANT_BOOL Value));
  STDMETHOD(set_Color(::OLE_COLOR Value));
  STDMETHOD(set_Ctl3D(VARIANT_BOOL Value));
  STDMETHOD(set_DefaultDrawing(VARIANT_BOOL Value));
  STDMETHOD(set_DoubleBuffered(VARIANT_BOOL Value));
  STDMETHOD(set_DragCursor(short Value));
  STDMETHOD(set_DragMode(TxDragMode Value));
  STDMETHOD(set_Enabled(VARIANT_BOOL Value));
  STDMETHOD(set_Font(IFontDisp* Value));
  STDMETHOD(set_FrameWidth(long Value));
  STDMETHOD(set_MinVisible(long Value));
  STDMETHOD(set_ParentColor(VARIANT_BOOL Value));
  STDMETHOD(set_ParentCtl3D(VARIANT_BOOL Value));
  STDMETHOD(set_RowCount(long Value));
  STDMETHOD(set_RowHeight(long Value));
  STDMETHOD(set_RowLineColor(::OLE_COLOR Value));
  STDMETHOD(set_RowLineWidth(long Value));
  STDMETHOD(set_TickColor(::OLE_COLOR Value));
  STDMETHOD(set_Units(long Value));
  STDMETHOD(set_UnitWidth(long Value));
  STDMETHOD(set_Visible(VARIANT_BOOL Value));
  STDMETHOD(SetSubComponent(VARIANT_BOOL IsSubComponent));
  STDMETHOD(UseRightToLeftReading(VARIANT_BOOL* Value));
  STDMETHOD(UseRightToLeftScrollBar(VARIANT_BOOL* Value));
  STDMETHOD(GetCellArray(LPSAFEARRAY* RowCells, long* ArraySize, long Row));
  STDMETHOD(InsertRowCell(IRowCellX* RowCellX));
  STDMETHOD(RemoveRowCell(IRowCellX* RowCellX));
  STDMETHOD(MouseToCell(IRowCellX** RowCellX, long X, long Y,
      TxCellState* CellState));
  STDMETHOD(get_ClientWidth(long* Value));
  STDMETHOD(set_ClientWidth(long Value));
  STDMETHOD(get_ClientHeight(long* Value));
  STDMETHOD(set_ClientHeight(long Value));
  STDMETHOD(get_HDC(void** Value));
  STDMETHOD(ClearRow(long Row));
  STDMETHOD(get_VerticalRows(VARIANT_BOOL* Value));
  STDMETHOD(set_VerticalRows(VARIANT_BOOL Value));
  STDMETHOD(get_AltKeyInserts(VARIANT_BOOL* Value));
  STDMETHOD(get_ShiftKeyHolds(VARIANT_BOOL* Value));
  STDMETHOD(set_AltKeyInserts(VARIANT_BOOL Value));
  STDMETHOD(set_ShiftKeyHolds(VARIANT_BOOL Value));
  STDMETHOD(get_CellState(TxCellState* Value));
  STDMETHOD(get_DragCell(IRowCellX** RowCellX));
  STDMETHOD(set_DragCell(IRowCellX* RowCellX));
  STDMETHOD(SortRow(long Row));
  STDMETHOD(get_ShiftKeySwaps(VARIANT_BOOL* Value));
  STDMETHOD(PaintCell(IRowCellX* RowCellX, VARIANT_BOOL ClearOnly));
  STDMETHOD(set_ShiftKeySwaps(VARIANT_BOOL Value));
  STDMETHOD(CellRect(IRectX** RectX, IRowCellX* RowCellX));
  STDMETHOD(RowLineRect(IRectX** RectX, long Row));
  STDMETHOD(ToggleFocus());
};
//---------------------------------------------------------------------------
#endif

